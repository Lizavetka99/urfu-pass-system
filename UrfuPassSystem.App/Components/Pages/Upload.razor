@using UrfuPassSystem.Domain.Services
@using UrfuPassSystem.Domain.Services.ImageHandler
@using UrfuPassSystem.Infrastructure.ArchiveHandler
@using UrfuPassSystem.Infrastructure.ImageStorage

@page "/upload"
@rendermode InteractiveServer
@inject IArchiveHandler ArchiveHandler
@inject IImageStorage ImageStorage
@inject IImageHandler ImageHandler
@inject ApplicationDbContext DbContext
@inject ILogger<Upload> Logger

<PageTitle>Загрузить</PageTitle>

<h1>Загрузить архив / изображение</h1>

<div style="margin-bottom: 20px; display: flex;">
    <div>Выберите файл:</div>
    <InputFile OnChange="FileUploaded" />
</div>

<h2>Выбранный файл:</h2>
<div>
    <img height="300" src="@Preview" />
    <div>Название: @FileName</div>
    <div>Размер: @FileSize.ToString("n0") (байт)</div>
    <div>Тип: @FileType</div>
</div>

<button type="button" class="btn btn-primary" @onclick="StartProcess">Обработать</button>

<div style="color: red;">@ErrorMessage</div>

<script lang="js">
    window.previewImage = (inputElem, imgElem) => {
        const url = URL.createObjectURL(inputElem.files[0]);
        imgElem.addEventListener('load', () => URL.revokeObjectURL(url), { once: true });
        imgElem.src = url;
    }
</script>

@code {
    public string FileName { get; set; } = "";
    public long FileSize { get; set; }
    public string FileType { get; set; } = "";
    public string? Preview { get; set; }
    public string ErrorMessage { get; set; } = "";

    public ITempFolger? TempFolger { get; set; }
    public string? FilePath{ get; set; }

    const int MAX_FILESIZE = 100 * 1024 * 1024; // 100 MB

    public async Task FileUploaded(InputFileChangeEventArgs e)
    {
        if (TempFolger != null)
        {
            TempFolger.Dispose();
            TempFolger = null;
            FilePath = null;
        }

        var file = e.File;
        if (file is null)
            return;

        FileSize = file.Size;
        FileType = file.ContentType;
        FileName = file.Name;

        var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".jfif", ".heic" };
        var archiveExtensions = new[] { ".zip", ".rar" };
        var fileExtension = Path.GetExtension(FileName).ToLower();

        if (!allowedExtensions.Contains(fileExtension) && !archiveExtensions.Contains(fileExtension))
        {
            ErrorMessage = "Недопустимый тип файла. Разрешены только .jpg, .jpeg, .png, .jfif, .heic, .zip, .rar.";
            Preview = string.Empty;
            return;
        }

        ErrorMessage = "";

        TempFolger = ImageStorage.CreateTempFolger();
        FilePath = Path.Combine(TempFolger.Path, FileName);

        await using var destinationStream = new FileStream(FilePath, FileMode.Create);
        await file.OpenReadStream(MAX_FILESIZE).CopyToAsync(destinationStream);

        if (FileType.StartsWith("image"))
            Preview = FilePath;
        else
            Preview = null;
    }

    private async Task StartProcess(MouseEventArgs e)
    {
        if (TempFolger == null)
        {
            ErrorMessage = "Файл не выбран";
            return;
        }
        try
        {
            var allowedExtensions = new[] { ".jpg", ".jpeg", ".png", ".jfif", ".heic" };

            if (FileType.Contains("zip") || FileType.Contains("rar"))
            {
                var randomFileName = Path.GetRandomFileName();
                var path = Path.GetFullPath(Path.Combine(TempFolger.Path, randomFileName));
                await ArchiveHandler.ExtractArchive(FilePath!, path);

                var files = Directory.GetFiles(path, "*", SearchOption.AllDirectories);
                var availableFiles = new List<string>();
                foreach (var file in files)
                {
                    var fileExtension = Path.GetExtension(file).ToLower();
                    if (!allowedExtensions.Contains(fileExtension))
                    {
                        ErrorMessage = $"Архив содержит недопустимый файл: {Path.GetFileName(file)}";
                    }
                    else
                        availableFiles.Add(file);
                }

                foreach (var file in availableFiles)
                    await SaveImage(file);
            }
            else
            {
                var fileExtension = Path.GetExtension(FilePath!).ToLower();
                if (!allowedExtensions.Contains(fileExtension))
                {
                    ErrorMessage = "Недопустимый тип файла.";
                    return;
                }
                await SaveImage(FilePath!);
            }
            Preview = null;
            FileName = "";
            FileSize = 0;
            FileType = "";
            ErrorMessage = "";
        }
        finally
        {
            TempFolger.Dispose();
            TempFolger = null;
            FilePath = null;
        }
    }

    private async Task SaveImage(string imagePath)
    {
        await ImageHandler.SaveAndCheckImage(DbContext, imagePath);
    }
}