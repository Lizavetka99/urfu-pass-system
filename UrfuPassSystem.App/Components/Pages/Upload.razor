@using UrfuPassSystem.Domain.Services
@using UrfuPassSystem.Domain.Services.ImageHandler
@using UrfuPassSystem.Infrastructure.ArchiveHandler
@using UrfuPassSystem.Infrastructure.ImageStorage

@page "/upload"
@rendermode InteractiveServer
@inject IArchiveHandler ArchiveHandler
@inject IImageStorage ImageStorage
@inject IImageHandler ImageHandler
@inject ApplicationDbContext DbContext
@inject ILogger<Upload> Logger

<PageTitle>Добавить архив/фото</PageTitle>

<h1>Добавить архив/фото</h1>

<div style="margin-bottom: 20px; display: flex;">
    <div>Выберите файлы:</div>
    <InputFile OnChange="FileUploaded" multiple />
</div>

<!--
<h2>Выбранный файл:</h2>
<div>
    <img height="300" src="@Preview" />
    <div>Название: @FileName</div>
    <div>Размер: @FileSize.ToString("n0") (байт)</div>
    <div>Тип: @FileType</div>
</div>
-->

@if (preview is not null)
{
    <img height="300" src="@preview" />
}
@foreach (var file in fileUploadProgresses)
{
    <div>
        @file.FileName
        <progress value="@file.UploadedBytes" max="@file.Size"></progress>
        @file.UploadedPercentage.ToString("F1")%
        (@FormatBytes(file.UploadedBytes) / @FormatBytes(file.Size))
    </div>
}

<button type="button" class="btn btn-primary" @onclick="StartProcess" disabled="@(loadingsInProgress > 0 || fileUploadProgresses.Count == 0 || processingInProgress)">Обработать</button>

@if (processingInProgress || processingFinished)
{
    @if (processingInProgress)
    {
        <div>Обработка файлов...</div>
    }
    @if (processingFinished)
    {
        <div>Обработка завершена.</div>
    }
    <div>Обработано: @processedCount</div>
    <div>Пропущено: @skippedCount</div>
}

<div style="color: red;">@errorMessage</div>

<!--
<script lang="js">
    window.previewImage = (inputElem, imgElem) => {
        const url = URL.createObjectURL(inputElem.files[0]);
        imgElem.addEventListener('load', () => URL.revokeObjectURL(url), { once: true });
        imgElem.src = url;
    }
</script>
-->
@code {
    const int MAX_FILES_COUNT = 100;
    const long MAX_FILE_SIZE = 10L * 1024 * 1024 * 1024; // 10 GB
    const long BUFFER_SIZE = 16384;
    const int WORKERS_COUNT = 4;
    private static readonly HashSet<string> _allowedExtensions = [".jpg", ".jpeg", ".png", ".jfif", ".heic", ".zip", ".rar"];
    private static readonly HashSet<string> _archiveExtensions = [".zip", ".rar"];
    private static readonly HashSet<string> _imageExtensions = [".jpg", ".jpeg", ".png", ".jfif", ".heic"];
     
    List<FileUploadProgress> fileUploadProgresses = [];
    HashSet<string> fileNames = [];
    ITempFolder? tempFolder;
    string? tempFolderMainSubFolder;
    string? preview;
    int loadingsInProgress = 0;
    bool processingInProgress = false;
    int processedCount = 0;
    int skippedCount = 0;
    bool processingFinished = false;

    string errorMessage = "";

    public async Task FileUploaded(InputFileChangeEventArgs e)
    {
        loadingsInProgress++;
        try
        {
            if (fileUploadProgresses.Count + e.FileCount > MAX_FILES_COUNT)
            {
                errorMessage = "Выбрано слишком много файлов.";
                return;
            }
            var files = e.GetMultipleFiles(MAX_FILES_COUNT);
            var startIndex = fileUploadProgresses.Count;

            foreach (var file in files)
            {
                var fileExtension = Path.GetExtension(file.Name).ToLower();
                if (!_allowedExtensions.Contains(fileExtension))
                {
                    errorMessage = $"{file.Name}: Недопустимый тип файла. Разрешены только {string.Join(' ', _allowedExtensions)}.";
                    return;
                }
                if (file.Size > MAX_FILE_SIZE)
                {
                    errorMessage = $"{file.Name}: Слишком большой файл. Максимальный размер файла 10 GB.";
                    return;
                }
                if (fileNames.Contains(file.Name))
                {
                    errorMessage = $"{file.Name}: Файл с таким названием уже загружен.";
                    return;
                }
                var progress = new FileUploadProgress(file.Name, file.Size, file.ContentType);
                fileUploadProgresses.Add(progress);
                fileNames.Add(file.Name);
            }

            if (tempFolder is not null && tempFolder.Disposed)
            {
                fileUploadProgresses.Clear();
                fileNames.Clear();
                tempFolder = null;
                tempFolderMainSubFolder = null;
                preview = null;
            }

            tempFolder ??= ImageStorage.CreateTempFolder(TimeSpan.FromHours(2));
            tempFolderMainSubFolder ??= tempFolder.CreateEmplySubFolder();
            errorMessage = "";

            await using var timer = new Timer(_ => InvokeAsync(() => StateHasChanged()));
            timer.Change(TimeSpan.FromMilliseconds(1000), TimeSpan.FromMilliseconds(1000));

            var buffer = new byte[BUFFER_SIZE];
            foreach (var file in files)
            {
                await using var sourceStream = file.OpenReadStream(MAX_FILE_SIZE);
                await using var destinationStream = new FileStream(Path.Combine(tempFolderMainSubFolder, file.Name), FileMode.CreateNew);
                while (await sourceStream.ReadAsync(buffer) is int length && length > 0)
                {
                    await destinationStream.WriteAsync(buffer, 0, length);
                    fileUploadProgresses[startIndex].UploadedBytes += length;
                }
                startIndex++;
            }
            if (fileUploadProgresses.Count == 1 && fileUploadProgresses[0].ContentType.StartsWith("image"))
                preview = Path.Combine(tempFolderMainSubFolder, fileUploadProgresses[0].FileName);
            else
                preview = null;
            StateHasChanged();
        }
        finally
        {
            loadingsInProgress--;
        }
    }

    private async Task StartProcess(MouseEventArgs e)
    {
        if (loadingsInProgress > 0 || fileUploadProgresses.Count == 0 || processingInProgress)
            return;

        if (tempFolder is null || tempFolder.Disposed)
        {
            fileUploadProgresses.Clear();
            fileNames.Clear();
            tempFolder = null;
            tempFolderMainSubFolder = null;
            preview = null;
            errorMessage = "Превышено время ожидания, файлы не сохранены. Попробуйте еще раз.";
            return;
        }
        processingFinished = false;
        skippedCount = 0;
        processedCount = 0;
        processingInProgress = true;
        await using var timer = new Timer(_ => InvokeAsync(() => StateHasChanged()));
        timer.Change(TimeSpan.FromMilliseconds(1000), TimeSpan.FromMilliseconds(1000));
        try
        {
            var tasks = new List<Task>(WORKERS_COUNT);
            var archiveTasks = new List<Task>();
            var archiveFolders = new Dictionary<Task, string>();
            var folderQueue = new Queue<string>([tempFolderMainSubFolder!]);
            while (folderQueue.Count > 0)
            {
                var folder = folderQueue.Dequeue();
                var files = Directory.GetFiles(folder, "*", SearchOption.AllDirectories);
                foreach (var file in files)
                {
                    var fileExtension = Path.GetExtension(file).ToLower();
                    if (_archiveExtensions.Contains(fileExtension))
                    {
                        var folderPath = tempFolder.CreateEmplySubFolder();
                        var task = ArchiveHandler.ExtractArchive(file, folderPath);
                        if (task.IsCompleted)
                        {
                            await task;
                            folderQueue.Enqueue(folderPath);
                        }
                        else
                        {
                            tasks.Add(task);
                            archiveTasks.Add(task);
                            archiveFolders.Add(task, folderPath);
                        }
                    }
                    else if (_imageExtensions.Contains(fileExtension))
                        tasks.Add(ImageHandler.SaveAndCheckImage(DbContext, file, false));
                    else
                    {
                        errorMessage = $"Недопустимый файл пропущен: {Path.GetFileName(file)}.";
                        skippedCount++;
                        continue;
                    }
                    if (tasks.Count >= WORKERS_COUNT)
                    {
                        var completed = await Task.WhenAny(tasks);
                        tasks.Remove(completed);
                        if (archiveTasks.Remove(completed))
                        {
                            folderQueue.Enqueue(archiveFolders[completed]);
                            archiveFolders.Remove(completed);
                        }
                        else
                            processedCount++;
                    }
                }
                if (folderQueue.Count == 0 && archiveTasks.Count > 0)
                {
                    var completed = await Task.WhenAny(archiveTasks);
                    tasks.Remove(completed);
                    archiveTasks.Remove(completed);
                    folderQueue.Enqueue(archiveFolders[completed]);
                    archiveFolders.Remove(completed);
                }
            }
            await Task.WhenAll(tasks);
            processedCount += tasks.Count;

            await DbContext.SaveChangesAsync();
            processingFinished = true;
        }
        finally
        {
            fileUploadProgresses.Clear();
            fileNames.Clear();
            tempFolder.Dispose();
            tempFolder = null;
            tempFolderMainSubFolder = null;
            preview = null;
            processingInProgress = false;
        }
    }

    private static readonly string[] _suffixes = ["B", "KB", "MB", "GB", "TB"];
    private static string FormatBytes(long bytes)
    {
        var index = 0;
        var size = (double)bytes;
        while (size >= 1024 && index < _suffixes.Length - 1)
        {
            size /= 1024;
            index++;
        }
        return $"{size:F2} {_suffixes[index]}";
    }

    record FileUploadProgress(string FileName, long Size, string ContentType)
    {
        public long UploadedBytes { get; set; }
        public double UploadedPercentage => (double)UploadedBytes / (double)Size * 100d;
    }
}